<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>심전도(ECG) 파형 분석 — 리듬 자동분류(교육시뮬레이션용)</title>
<style>
  :root{--bg:#f6f8fa;--card:#fff;--muted:#6b7280;--ok:#059669;--warn:#d97706;--alert:#dc2626;--info:#0f62fe}
  body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;margin:18px;background:var(--bg);color:#0b1220}
  h1{font-size:20px;margin-bottom:6px}
  .card{background:var(--card);padding:14px;border-radius:10px;box-shadow:0 6px 18px rgba(11,17,32,0.06);margin-bottom:12px}
  label{display:block;margin-top:8px;font-size:13px}
  input,select,button{padding:8px 10px;border-radius:8px;border:1px solid #d6dbe3;font-size:14px}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  canvas{max-width:100%;border:1px solid #e1e6ef;border-radius:8px}
  .stats{margin-top:10px;font-size:14px}
  .small{font-size:13px;color:var(--muted)}
  .btn-primary{background:var(--info);color:white;border:none}
  .btn-ghost{background:transparent;border:1px solid #d6dbe3}
  .result-card{padding:12px;border-radius:8px;color:white;font-weight:600;margin-bottom:6px}
  .result-green{background:linear-gradient(90deg, rgba(5,150,105,0.95), rgba(34,197,94,0.9));}
  .result-orange{background:linear-gradient(90deg, rgba(217,119,6,0.95), rgba(245,158,11,0.9));}
  .result-red{background:linear-gradient(90deg, rgba(220,38,38,0.95), rgba(239,68,68,0.9));}
  .result-gray{background:linear-gradient(90deg, rgba(156,163,175,0.95), rgba(107,114,128,0.9));}
  .meta{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
</style>
</head>
<body>
<h1>심전도(ECG) 파형 이미지 업로드 및 자동 분석</h1>

<div class="card">
  <label>이미지 업로드 (JPG/PNG)</label>
  <input id="fileInput" type="file" accept="image/*">
  <div class="controls">
    <div>
      <label>종이 속도</label>
      <select id="paperSpeed">
        <option value="25">25 mm/s (일반)</option>
        <option value="50">50 mm/s</option>
      </select>
    </div>
    <div>
      <label>mm per pixel</label>
      <input id="mmPerPixel" type="number" step="0.0001" value="0.2646">
    </div>
    <div>
      <label>노이즈 제거 윈도우 (픽셀)</label>
      <input id="smooth" type="number" value="5" min="1">
    </div>
    <div style="align-self:end">
      <button id="analyzeBtn" class="btn-primary">분석 시작</button>
      <button id="resetBtn" class="btn-ghost">초기화</button>
    </div>
  </div>
</div>

<div class="card">
  <canvas id="imgCanvas"></canvas>
  <div class="meta">
    <div style="flex:2" id="results"></div>
  </div>
  <div style="margin-top:8px;display:flex;gap:8px">
    <button id="togglePeaks" class="btn-ghost">R파 표시 토글</button>
    <button id="downloadCsv" class="btn-ghost">RR 간격 CSV로 다운로드</button>
  </div>
</div>

<script>
const fileInput=document.getElementById('fileInput');
const canvas=document.getElementById('imgCanvas');
const ctx=canvas.getContext('2d');
const analyzeBtn=document.getElementById('analyzeBtn');
const resetBtn=document.getElementById('resetBtn');
const resultsDiv=document.getElementById('results');
const mmPerPixelInput=document.getElementById('mmPerPixel');
const paperSpeedSelect=document.getElementById('paperSpeed');
const smoothInput=document.getElementById('smooth');
const togglePeaksBtn=document.getElementById('togglePeaks');
const downloadCsvBtn=document.getElementById('downloadCsv');

let originalImage=null;
let waveform=null;
let peaks=[];
let showPeaks=true;

fileInput.addEventListener('change',e=>{
  const f=e.target.files[0];
  if(!f) return;
  const img=new Image();
  img.onload=()=>{
    const maxW=1400;
    const scale=Math.min(1,maxW/img.width);
    canvas.width=Math.round(img.width*scale);
    canvas.height=Math.round(img.height*scale);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0,canvas.width,canvas.height);
    originalImage=img; waveform=null; peaks=[];
    resultsDiv.innerHTML='<div class="small">이미지 로드 완료. "분석 시작"을 눌러주세요.</div>';
  };
  img.src=URL.createObjectURL(f);
});

function movingAverage(arr,w){
  const out=new Float32Array(arr.length);
  const half=Math.floor(w/2);
  for(let i=0;i<arr.length;i++){
    let s=0,c=0;
    for(let j=i-half;j<=i+half;j++) if(j>=0&&j<arr.length){s+=arr[j]; c++;}
    out[i]=c?s/c:0;
  }
  return out;
}

function std(arr,meanVal){
  const m=(meanVal!==undefined)?meanVal:(arr.reduce((a,b)=>a+b,0)/arr.length||0);
  return Math.sqrt(arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length||0);
}

function findPeaks(signal,opts){
  const {minDist=30,thresh=0}=opts||{};
  const peaks=[]; let last=-Infinity;
  for(let i=1;i<signal.length-1;i++){
    if(signal[i]>signal[i-1]&&signal[i]>signal[i+1]&&signal[i]>thresh){
      if(i-last>=minDist){peaks.push(i); last=i;}
    }
  }
  return peaks;
}

function measureQRSwidth(signal,peakIdx){
  const peakVal=signal[peakIdx];
  const L=Math.max(0,peakIdx-40),R=Math.min(signal.length-1,peakIdx+40);
  const base=signal.slice(L,R+1).reduce((a,b)=>a+b,0)/(R-L+1);
  const half=base+(peakVal-base)/2;
  let left=peakIdx; while(left>0&&signal[left]>half) left--;
  let right=peakIdx; while(right<signal.length-1&&signal[right]>half) right++;
  return {left,right,widthPx:right-left};
}

function classifyRhythm(rrArray,bpm,rrCV,qrsWidthsMs){
  if(!rrArray||rrArray.length<3) return {text:'분석 불충분',color:'result-gray'};
  const medQrs=qrsWidthsMs.length?qrsWidthsMs.sort((a,b)=>a-b)[Math.floor(qrsWidthsMs.length/2)]:80;
  if(bpm<60) return {text:'동성 서맥 (Sinus Bradycardia)',color:'result-orange'};
  if(bpm>100&&rrCV<0.1) return {text:'동성 빈맥 (Sinus Tachycardia)',color:'result-orange'};
  if(rrCV>0.2) return {text:'심방세동 가능성 (AF)',color:'result-orange'};
  if(medQrs>120&&bpm>100) return {text:'심실빈맥 가능성 (VT)',color:'result-red'};
  if(medQrs>120&&rrCV<0.1) return {text:'조기심실수축 의심 (PVC)',color:'result-orange'};
  return {text:'정상 동율동 (Normal Sinus Rhythm)',color:'result-green'};
}

analyzeBtn.addEventListener('click',()=>{
  if(!originalImage&&!canvas.width) return alert('먼저 이미지를 업로드하세요.');
  const mmPerPixel=parseFloat(mmPerPixelInput.value)||0.2646;
  const paperSpeed=parseFloat(paperSpeedSelect.value)||25;
  const smoothN=Math.max(1,parseInt(smoothInput.value)||5);

  const imgData=ctx.getImageData(0,0,canvas.width,canvas.height);
  const data=imgData.data;
  const W=canvas.width,H=canvas.height;
  const columnY=new Float32Array(W);
  for(let x=0;x<W;x++){
    let minB=255,minY=H/2;
    for(let y=0;y<H;y++){
      const idx=(y*W+x)*4;
      const r=data[idx],g=data[idx+1],b=data[idx+2];
      const bright=0.299*r+0.587*g+0.114*b;
      if(bright<minB){minB=bright; minY=y;}
    }
    columnY[x]=minY;
  }

  let yvals=movingAverage(columnY,smoothN);
  const minY=Math.min(...yvals),maxY=Math.max(...yvals);
  const signal=new Float32Array(W);
  for(let i=0;i<W;i++) signal[i]=maxY-yvals[i];
  const signalSm=movingAverage(signal,3);

  const meanSignal=signalSm.reduce((a,b)=>a+b,0)/W;
  const sdSignal=std(signalSm,meanSignal);
  const thresh=meanSignal+Math.max(1.0,0.8*sdSignal);
  const minDistPx=Math.round(0.2/(mmPerPixel/paperSpeed));
  peaks=findPeaks(signalSm,{minDist:minDistPx,thresh});
  const timePerPixel=mmPerPixel/paperSpeed;
  const rr=[];
  for(let i=1;i<peaks.length;i++) rr.push((peaks[i]-peaks[i-1])*timePerPixel);
  const meanRR=rr.length?rr.reduce((a,b)=>a+b,0)/rr.length:NaN;
  const bpm=rr.length?Math.round(60/meanRR):NaN;
  const rrCV=rr.length?std(rr,meanRR)/meanRR:0;
  const qrsWidthsMs=peaks.map(p=>measureQRSwidth(signalSm,p).widthPx*timePerPixel*1000);
  waveform={yvals,signal:signalSm,peaks,timePerPixel,W,H};
  redraw();

  const rhythm=classifyRhythm(rr,bpm,rrCV,qrsWidthsMs);
  let html='';
  html+=`<div class="result-card ${rhythm.color}">${rhythm.text}</div>`;
  html+=`<div><strong>R파 개수:</strong> ${peaks.length}</div>`;
  html+=`<div><strong>평균 RR 간격:</strong> ${rr.length?meanRR.toFixed(3)+' s':'검출 불충분'}</div>`;
  html+=`<div><strong>추정 BPM:</strong> ${!isNaN(bpm)?bpm+' bpm':'검출 불충분'}</div>`;
  html+=`<div class="small"><strong>RR CV:</strong> ${(rrCV*100).toFixed(1)}%</div>`;
  html+=`<div class="small"><strong>QRS 폭 중앙값:</strong> ${qrsWidthsMs.length?Math.round(qrsWidthsMs.sort((a,b)=>a-b)[Math.floor(qrsWidthsMs.length/2)])+' ms':'검출 불충분'}</div>`;
  html+=`<div class="small" style="margin-top:4px">시간 변환: mm/pixel=${mmPerPixel}, paper speed=${paperSpeed} mm/s → 1픽셀=${timePerPixel.toFixed(5)} s</div>`;
  resultsDiv.innerHTML=html;
});

function redraw(){
  if(!waveform) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(originalImage,0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.lineWidth=2; ctx.strokeStyle='rgba(3,105,161,0.9)';
  ctx.beginPath();
  for(let x=0;x<waveform.W;x++){
    const y=waveform.yvals[x];
    if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  ctx.lineWidth=1.2; ctx.strokeStyle='rgba(12,21,34,0.9)';
  ctx.beginPath();
  for(let x=0;x<waveform.W;x++){
    const val=waveform.signal[x];
    const scaled=waveform.H*0.5-(val-Math.min(...waveform.signal))/(Math.max(...waveform.signal)-Math.min(...waveform.signal)+1e-6)*(waveform.H*0.45);
    if(x===0) ctx.moveTo(x,scaled); else ctx.lineTo(x,scaled);
  }
  ctx.stroke();

  if(showPeaks){
    ctx.fillStyle='rgba(220,38,38,0.9)';
    for(const p of waveform.peaks){
      const py=waveform.yvals[p];
      ctx.beginPath(); ctx.arc(p,py,4,0,Math.PI*2); ctx.fill();
    }
  }
  ctx.restore();
}

togglePeaksBtn.addEventListener('click',()=>{showPeaks=!showPeaks; redraw(); togglePeaksBtn.textContent=showPeaks?'R파 숨기기':'R파 표시';});
resetBtn.addEventListener('click',()=>{ctx.clearRect(0,0,canvas.width,canvas.height); originalImage=null; waveform=null; peaks=[]; resultsDiv.innerHTML=''; fileInput.value='';});
downloadCsvBtn.addEventListener('click',()=>{
  if(!waveform||!waveform.peaks.length) return alert('분석된 RR 간격이 없습니다.');
  const rr=[];
  for(let i=1;i<waveform.peaks.length;i++) rr.push((waveform.peaks[i]-waveform.peaks[i-1])*waveform.timePerPixel);
  let csv='index,rr_seconds\n'; rr.forEach((v,i)=>csv+=`${i+1},${v.toFixed(6)}\n`);
  const blob=new Blob([csv],{type:'text/csv'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='rr_intervals.csv'; a.click(); URL.revokeObjectURL(url);
});

window.addEventListener('resize',()=>{if(waveform) redraw();});
</script>
</body>
</html>

